/**
 * Record Basics - Introduction to Java Records (Java 14+)
 * 
 * Records are a special kind of class that act as transparent carriers for
 * immutable data. They dramatically reduce boilerplate code.
 * 
 * Java 25 Status: Records are a stable feature, fully supported.
 */

// Basic record definition
record Person(String name, int age) {}

// Record with multiple components
record Point(int x, int y) {}

// Record with validation
record Employee(String name, String id, double salary) {
    // Compact constructor for validation
    public Employee {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
        if (salary < 0) {
            throw new IllegalArgumentException("Salary cannot be negative");
        }
    }
}

// Record implementing interface
interface Describable {
    String description();
}

record Product(String name, double price) implements Describable {
    @Override
    public String description() {
        return String.format("%s ($%.2f)", name, price);
    }
}

// Generic record
record Pair<T, U>(T first, U second) {}

public class RecordBasics {
    
    public static void main(String[] args) {
        System.out.println("=== Java Records Basics ===\n");
        
        demonstrateBasicRecord();
        demonstrateAutoGeneratedMethods();
        demonstrateImmutability();
        demonstrateValidation();
        demonstrateRecordWithInterface();
        demonstrateGenericRecord();
        demonstrateComparison();
    }
    
    /**
     * Basic record creation and usage
     */
    private static void demonstrateBasicRecord() {
        System.out.println("1. Basic Record:");
        
        // Creating a record instance
        Person person = new Person("Alice", 30);
        
        // Accessing components (note: no "get" prefix)
        System.out.println("   Name: " + person.name());
        System.out.println("   Age: " + person.age());
        
        // Point record
        Point point = new Point(10, 20);
        System.out.println("   Point: x=" + point.x() + ", y=" + point.y());
        
        System.out.println();
    }
    
    /**
     * Automatically generated methods
     */
    private static void demonstrateAutoGeneratedMethods() {
        System.out.println("2. Auto-Generated Methods:");
        
        Person person1 = new Person("Bob", 25);
        Person person2 = new Person("Bob", 25);
        Person person3 = new Person("Charlie", 30);
        
        // toString() - automatically generated
        System.out.println("   toString(): " + person1);
        
        // equals() - automatically generated
        System.out.println("   person1.equals(person2): " + person1.equals(person2));
        System.out.println("   person1.equals(person3): " + person1.equals(person3));
        
        // hashCode() - automatically generated
        System.out.println("   person1.hashCode(): " + person1.hashCode());
        System.out.println("   person2.hashCode(): " + person2.hashCode());
        System.out.println("   Hash codes equal: " + (person1.hashCode() == person2.hashCode()));
        
        System.out.println();
    }
    
    /**
     * Records are immutable
     */
    private static void demonstrateImmutability() {
        System.out.println("3. Immutability:");
        
        Person person = new Person("David", 35);
        System.out.println("   Original: " + person);
        
        // Cannot modify - fields are final
        // person.age = 40; // Compilation error!
        
        // To "modify", create a new instance
        Person updatedPerson = new Person(person.name(), 40);
        System.out.println("   Updated (new instance): " + updatedPerson);
        System.out.println("   Original unchanged: " + person);
        
        System.out.println();
    }
    
    /**
     * Validation in record constructors
     */
    private static void demonstrateValidation() {
        System.out.println("4. Validation:");
        
        try {
            Employee valid = new Employee("John Doe", "E123", 50000);
            System.out.println("   Valid employee: " + valid);
            
            // This will throw exception
            Employee invalid = new Employee("", "E124", 60000);
        } catch (IllegalArgumentException e) {
            System.out.println("   Validation error: " + e.getMessage());
        }
        
        try {
            // Negative salary
            Employee invalid = new Employee("Jane Doe", "E125", -1000);
        } catch (IllegalArgumentException e) {
            System.out.println("   Validation error: " + e.getMessage());
        }
        
        System.out.println();
    }
    
    /**
     * Record implementing interface
     */
    private static void demonstrateRecordWithInterface() {
        System.out.println("5. Record with Interface:");
        
        Product product1 = new Product("Laptop", 999.99);
        Product product2 = new Product("Mouse", 29.99);
        
        System.out.println("   " + product1.description());
        System.out.println("   " + product2.description());
        
        // Can use as interface type
        Describable item = product1;
        System.out.println("   As interface: " + item.description());
        
        System.out.println();
    }
    
    /**
     * Generic records
     */
    private static void demonstrateGenericRecord() {
        System.out.println("6. Generic Record:");
        
        // Pair of String and Integer
        Pair<String, Integer> pair1 = new Pair<>("Age", 30);
        System.out.println("   " + pair1.first() + ": " + pair1.second());
        
        // Pair of two Strings
        Pair<String, String> pair2 = new Pair<>("First Name", "Last Name");
        System.out.println("   " + pair2);
        
        // Pair of Integer and Double
        Pair<Integer, Double> pair3 = new Pair<>(10, 3.14);
        System.out.println("   Number: " + pair3.first() + ", Pi: " + pair3.second());
        
        System.out.println();
    }
    
    /**
     * Comparing records with traditional classes
     */
    private static void demonstrateComparison() {
        System.out.println("7. Record vs Traditional Class:");
        
        // Record
        Person recordPerson = new Person("Alice", 30);
        System.out.println("   Record: " + recordPerson);
        System.out.println("   Record code lines: ~1 line");
        
        // Traditional class (would require 30+ lines)
        TraditionalPerson classPerson = new TraditionalPerson("Alice", 30);
        System.out.println("   Class: " + classPerson);
        System.out.println("   Class code lines: ~30+ lines");
        
        // Both provide same functionality
        System.out.println("   Equal functionality: " + 
                         (recordPerson.name().equals(classPerson.getName()) &&
                          recordPerson.age() == classPerson.getAge()));
    }
}

// Traditional class for comparison (lots of boilerplate!)
class TraditionalPerson {
    private final String name;
    private final int age;
    
    public TraditionalPerson(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        TraditionalPerson that = (TraditionalPerson) obj;
        return age == that.age && name.equals(that.name);
    }
    
    @Override
    public int hashCode() {
        return 31 * name.hashCode() + age;
    }
    
    @Override
    public String toString() {
        return "TraditionalPerson[name=" + name + ", age=" + age + "]";
    }
}

/**
 * Record Basics Summary:
 * 
 * What Records Provide Automatically:
 * 1. Private final fields for each component
 * 2. Public accessor methods (without "get" prefix)
 * 3. Constructor with all components as parameters
 * 4. equals() method (compares all fields)
 * 5. hashCode() method (based on all fields)
 * 6. toString() method (formatted representation)
 * 
 * Record Syntax:
 *   record RecordName(Type1 field1, Type2 field2) {}
 * 
 * Benefits:
 * - Dramatically less code (1 line vs 30+ lines)
 * - Immutable by default (thread-safe)
 * - Clear intent (data carrier)
 * - Compiler-generated equals/hashCode/toString
 * - Better performance (JVM optimizations)
 * 
 * Restrictions:
 * - Cannot extend other classes
 * - All fields are final
 * - Cannot declare additional instance fields
 * - Cannot be abstract
 * 
 * Use Cases:
 * - DTOs (Data Transfer Objects)
 * - API responses
 * - Configuration objects
 * - Immutable data structures
 * - Return types for multiple values
 * 
 * Practice:
 * - Convert existing POJOs to records
 * - Create records for domain models
 * - Use records in collections
 * - Combine records with pattern matching
 */
